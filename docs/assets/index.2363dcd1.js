import{c as v,t as p,a as c,r as h,b as u}from"./vendor.3248a3e5.js";const m=function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))i(e);new MutationObserver(e=>{for(const t of e)if(t.type==="childList")for(const s of t.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&i(s)}).observe(document,{childList:!0,subtree:!0});function a(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerpolicy&&(t.referrerPolicy=e.referrerpolicy),e.crossorigin==="use-credentials"?t.credentials="include":e.crossorigin==="anonymous"?t.credentials="omit":t.credentials="same-origin",t}function i(e){if(e.ep)return;e.ep=!0;const t=a(e);fetch(e.href,t)}};m();const f="_App_12vbh_12",g="_header_12vbh_17",y="_nav_12vbh_27",_="_c_call_1_12vbh_43",w="_fnt_ser_1_12vbh_61",$="_link_12vbh_66";var b={App:f,header:g,nav:y,c_call_1:_,fnt_ser_1:w,link:$,"logo-spin":"_logo-spin_12vbh_1"},k="/assets/blob.c92541e0.svg",x="/assets/pattern (6).38217069.svg",T="/assets/pattern (7).0720a08d.svg",A="/assets/blob (2).5de09852.svg";const N=p(`<div><style></style><div class="b-roads"><div></div><div><p>@hwyblvd</p><h2>Solving state management, permanently.</h2><small><a href="#hwyblvd-theme">I'm just looking around<b>&lt;</b></a><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="https://github.com/aikmandean/st">I'm looking to get started<i>&gt;</i></a></small></div></div><div id="hwyblvd-theme" class="b-jets"><div><h2>Right once, <br>&nbsp;&nbsp;&nbsp;&nbsp; <b>never</b> <br>rewrite.</h2></div><div><p>Why do we rewrite? Architecture. Entangled code, changing libraries, new ideas. <br><br>@hwyblvd helps you lay a strongly-typed foundation for your app. TypeScript not required.<br><br><small>What's the secret?<br><br>No global state. We give you a few primitives to declare state, depend on it, but also free it up, then eliminate any globals you find you no longer need.</small>\`</p></div></div><div style="max-width: 100vw; overflow: hidden;"><div style="height: 10em"></div><div class="b-papr"><div><h2>Type safety first</h2></div><div><p><br><br>This is our home-made, secret sauce. <br><br>We can detect all your dependencies, in every function. The whole callstack, even nested functions. <b>Before</b> you ever run a line of code.<br><br><small style="display: none;">Types? No thanks, are you going to turn my code into Java?<br><br>Don't worry, we have two friends that'll make sure your code won't become a verbose, type-soup. <br><br>1) Automatic detection \u{1F916}, 2) Type composer \u{1F468}\u{1F3FC}\u200D\u{1F3A4}</small>\`</p></div></div><div class="b-bar"><aside></aside><div><div><h3>No problem is more challenging than state. From paradigms to design patterns, we're always solving for state.</h3><br><hr><br></div><p>The Project<i><a href="https://www.npmjs.com/package/@hwyblvd/st">@hwyblvd/st</a></i></p><p>Frontend<i>@hwyblvd/st+</i></p><p>Serverside<i><a href="https://www.npmjs.com/~hwyblvd">@hwyblvd/server @hwyblvd/swagger</a></i></p><p>More<i><a href="https://github.com/aikmandean/st/blob/master/index.d.ts#L48">TypeDefinition() IsComposable&lt;T&gt;</a></i></p></div></div><div class="b-code"><aside></aside></div></div></div>`),S=()=>(()=>{const o=N.cloneNode(!0),r=o.firstChild,a=r.nextSibling,i=a.firstChild,e=i.nextSibling,t=e.firstChild,s=t.nextSibling;return r.textContent=`
        :root {
          scroll-behavior: smooth;
          --bghex: url('${k}');
          --bgarcs: url('${x}');
          --bgplan: url('${T}');
          --bgstars: url('${A}');
        }  
      `,v(n=>{const l=b.App,d=b.fnt_ser_1;return l!==n._v$&&c(o,n._v$=l),d!==n._v$2&&c(s,n._v$2=d),n},{_v$:void 0,_v$2:void 0}),o})();h(()=>u(S,{}),document.getElementById("root"));
